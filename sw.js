const CACHE_NAME="hocg-deck-convert-v0.2.11";const BASE_PATH="/hocg-deck-convert";let offlineHint=false;const CARD_CACHE_NAME="hocg-deck-convert-cards";const CARDS_DB_URL="https://qrimpuff.github.io/hocg-fan-sim-assets/hocg_cards.json";const IMAGE_BASE_JP="https://qrimpuff.github.io/hocg-fan-sim-assets/img/";const IMAGE_BASE_EN="https://qrimpuff.github.io/hocg-fan-sim-assets/img_en/";const ASSETS=[BASE_PATH+"/",BASE_PATH+"/index.html",BASE_PATH+"/assets/android-chrome-192x192.png",BASE_PATH+"/assets/arts_green.png",BASE_PATH+"/assets/card-back.webp",BASE_PATH+"/assets/arts_white.png",BASE_PATH+"/assets/image.png",BASE_PATH+"/assets/arts_red.png",BASE_PATH+"/assets/arts_purple.png",BASE_PATH+"/assets/favicon.ico",BASE_PATH+"/assets/android-chrome-512x512.png",BASE_PATH+"/assets/style.css",BASE_PATH+"/assets/arts_null.png",BASE_PATH+"/assets/arts_yellow.png",BASE_PATH+"/assets/favicon-16x16.png",BASE_PATH+"/assets/untrack.html",BASE_PATH+"/assets/arts_blue.png",BASE_PATH+"/assets/cheer-back.webp",BASE_PATH+"/assets/apple-touch-icon.png",BASE_PATH+"/assets/favicon-32x32.png",BASE_PATH+"/assets/site.webmanifest"];const INDEX_URL=BASE_PATH+"/index.html";function buildPrefetchRequest(url){try{const resolved=new URL(url,self.location.origin);return new Request(resolved.toString(),{mode:"cors",credentials:"omit",cache:"no-store"});}catch(error){console.warn("[SW] Invalid prefetch URL",url,error);return null;}}function normalizeAssetUrl(url){if(!url)return null;if(url.startsWith("http://")||url.startsWith("https://"))return url;if(url.startsWith("/"))return url;return BASE_PATH+"/"+url.replace(/^\.\//,"");}function extractHashedAssets(htmlText){const urls=new Set;const patterns=[/<script[^>]+src="([^"]+)"/gi,/<link[^>]+href="([^"]+)"/gi];patterns.forEach(re=>{let match;while(match=re.exec(htmlText)){const url=normalizeAssetUrl(match[1]);if(url)urls.add(url);}});return Array.from(urls).filter(url=>{const isAppAsset=typeof url==="string"&&url.startsWith(BASE_PATH+"/");if(!isAppAsset)return false;return url.endsWith(".js")||url.endsWith(".wasm")||url.endsWith(".css");});}function extractWasmAssetsFromJs(jsText){if(!jsText)return[];const urls=new Set;const wasmStringRe=/["'`]([^"'`\s]+\.wasm(?:\?[^"'`\s]+)?)['"`]/g;let match;while(match=wasmStringRe.exec(jsText)){const candidate=match[1];if(!candidate)continue;if(candidate.startsWith("data:"))continue;const normalized=normalizeAssetUrl(candidate);if(normalized&&normalized.startsWith(BASE_PATH+"/assets/")){urls.add(normalized);}}return Array.from(urls);}function extractExternalStylesheetLinks(htmlText){if(!htmlText)return[];const urls=new Set;const re=/<link\s+[^>]*rel=["']stylesheet["'][^>]*href=["']([^"']+)["'][^>]*>/gi;let match;while(match=re.exec(htmlText)){const href=(match[1]||"").trim();if(!href)continue;if(href.startsWith("http://")||href.startsWith("https://")){urls.add(href);}}return Array.from(urls);}async function cacheAddAllBestEffort(cache,urls){for(const url of urls){try{await cache.add(url);}catch(error){console.warn("[SW] Failed to pre-cache",url,error);}}}function extractUrlsFromCss(cssText,baseUrl){if(!cssText)return[];const urls=new Set;const re=/url\(\s*(['"]?)([^'"\)]+)\1\s*\)/g;let match;while(match=re.exec(cssText)){const raw=(match[2]||"").trim();if(!raw)continue;if(raw.startsWith("data:"))continue;try{const resolved=new URL(raw,baseUrl).toString();urls.add(resolved);}catch(_){}}return Array.from(urls);}async function fetchAndCacheTextAsset(cache,url){const response=await fetch(url,{cache:"no-store"});if(!response||!(response.ok||response.type==="opaque")){throw new Error("Failed to fetch "+url+" ("+(response?response.status:"no response")+")");}await cache.put(url,response.clone());if(response.type==="opaque"){return null;}return await response.text();}async function matchFromKnownCaches(request){try{const appCache=await caches.open(CACHE_NAME);const cached=await appCache.match(request,{ignoreVary:true});if(cached)return cached;}catch(_){}try{const cardCache=await caches.open(CARD_CACHE_NAME);return await cardCache.match(request,{ignoreVary:true});}catch(_){return undefined;}}self.addEventListener("install",event=>{self.skipWaiting();event.waitUntil(caches.open(CACHE_NAME).then(async cache=>{console.log("[SW] Pre-caching assets");await cache.addAll(ASSETS);try{const response=await fetch(INDEX_URL,{cache:"no-store"});const htmlText=await response.text();const hashedAssets=extractHashedAssets(htmlText);await cache.addAll(hashedAssets);const jsAssets=hashedAssets.filter(url=>url.endsWith(".js")&&url.startsWith(BASE_PATH+"/"));const wasmAssets=new Set;for(const jsUrl of jsAssets){try{const cachedJs=await cache.match(jsUrl,{ignoreVary:true});if(!cachedJs)continue;const jsText=await cachedJs.clone().text();for(const wasmUrl of extractWasmAssetsFromJs(jsText)){wasmAssets.add(wasmUrl);}}catch(error){console.warn("[SW] Failed to scan JS for WASM",jsUrl,error);}}if(wasmAssets.size>0){await cacheAddAllBestEffort(cache,Array.from(wasmAssets));}await cacheAddAllBestEffort(cache,[CARDS_DB_URL]);try{const externalCssUrls=extractExternalStylesheetLinks(htmlText);for(const cssUrl of externalCssUrls){try{const cssText=await fetchAndCacheTextAsset(cache,cssUrl);if(!cssText)continue;const referenced=extractUrlsFromCss(cssText,cssUrl);await cacheAddAllBestEffort(cache,referenced);}catch(error){console.warn("[SW] External CSS pre-cache skipped",cssUrl,error);}}}catch(error){console.warn("[SW] External CSS pre-cache skipped",error);}}catch(error){console.warn("[SW] Failed to pre-cache hashed assets",error);}}));});self.addEventListener("activate",event=>{event.waitUntil(caches.keys().then(cacheNames=>{return Promise.all(cacheNames.map(cacheName=>{if(cacheName!==CACHE_NAME&&cacheName!==CARD_CACHE_NAME){return caches.delete(cacheName);}}));}).then(()=>self.clients.claim()));});self.addEventListener("fetch",event=>{if(event.request.method!=="GET"){return;}if(offlineHint){event.respondWith(matchFromKnownCaches(event.request).then(cached=>{if(cached)return cached;return fetch(event.request);}));return;}if(event.request.mode==="navigate"){event.respondWith(fetch(event.request).catch(()=>{return caches.match(BASE_PATH+"/index.html")||caches.match(BASE_PATH+"/");}));return;}event.respondWith(fetch(event.request).then(networkResponse=>{if(networkResponse&&(networkResponse.ok||networkResponse.type==="opaque")){const responseToCache=networkResponse.clone();const url=event.request.url||"";const isCardImage=url.startsWith(IMAGE_BASE_JP)||url.startsWith(IMAGE_BASE_EN);const targetCache=isCardImage?CARD_CACHE_NAME:CACHE_NAME;caches.open(targetCache).then(cache=>{cache.put(event.request,responseToCache);});}return networkResponse;}).catch(()=>{return matchFromKnownCaches(event.request);}));});self.addEventListener("message",event=>{if(event.data&&event.data.type==="OFFLINE_HINT"){offlineHint=!!event.data.offline;return;}if(event.data&&event.data.type==="PREFETCH_CARDS"){const urls=event.data.urls;const client=event.source;console.log("[SW] Prefetching "+urls.length+" cards...");event.waitUntil(caches.open(CARD_CACHE_NAME).then(async cache=>{const expectedUrls=new Set(urls);try{const cachedRequests=await cache.keys();await Promise.all(cachedRequests.map(async request=>{const url=request.url||"";const isCardImage=url.startsWith(IMAGE_BASE_JP)||url.startsWith(IMAGE_BASE_EN);if(!isCardImage)return;if(expectedUrls.has(url))return;await cache.delete(request,{ignoreVary:true});}));}catch(error){console.warn("[SW] Failed pruning stale cards",error);}const progressTargets=[];if(client&&typeof client.postMessage==="function"){progressTargets.push(client);}else{try{const clients=await self.clients.matchAll({type:"window",includeUncontrolled:true});progressTargets.push(...clients);}catch(_){}}let completed=0;let totalBytes=0;const CONCURRENCY=(self.navigator.hardwareConcurrency||4)*4;let lastProgressAt=0;const sendProgress=(delta=0,force=false)=>{completed+=delta;if(progressTargets.length===0)return;const now=Date.now();if(!force&&now-lastProgressAt<16)return;lastProgressAt=now;const message={type:"PREFETCH_PROGRESS",loaded:Math.min(completed,urls.length),total:urls.length,size:totalBytes};for(const target of progressTargets){try{target.postMessage(message);}catch(_){}}};sendProgress(0,true);const workerCount=Math.max(1,Math.min(CONCURRENCY,urls.length));const worker=async workerId=>{for(let idx=workerId;idx<urls.length;idx+=workerCount){const url=urls[idx];try{const cached=await cache.match(url,{ignoreVary:true});if(cached){continue;}const request=buildPrefetchRequest(url);if(!request){continue;}const response=await fetch(request);if(response&&(response.ok||response.type==="opaque")){const len=response.headers.get("content-length");if(len)totalBytes+=parseInt(len,10);await cache.put(url,response);}}catch(error){console.error(error);}finally{sendProgress(1);}}};await Promise.all(Array.from({length:workerCount},(_v,i)=>worker(i)));sendProgress(0,true);}));}});